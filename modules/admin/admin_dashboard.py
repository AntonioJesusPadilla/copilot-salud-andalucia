"""
Dashboard de Administraci√≥n - Copilot Salud Andaluc√≠a
Panel de control para monitorear rendimiento y seguridad
"""

import streamlit as st
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
from datetime import datetime, timedelta
from typing import Dict, Any, List
import json
import os
import numpy as np
import time

# Importar widgets espec√≠ficos para admin
try:
    from modules.admin.admin_widgets import AdminWidgets
    ADMIN_WIDGETS_AVAILABLE = True
except ImportError:
    ADMIN_WIDGETS_AVAILABLE = False

# Importar sistemas mock para cuando los reales no est√©n disponibles
try:
    from modules.admin.mock_systems import initialize_admin_systems_safely
    MOCK_SYSTEMS_AVAILABLE = True
except ImportError:
    MOCK_SYSTEMS_AVAILABLE = False

class AdminDashboard:
    def __init__(self):
        """Inicializar dashboard de administraci√≥n"""
        self.performance_optimizer = None
        self.security_auditor = None
        self.rate_limiter = None
        self.data_encryption = None
        self.systems_initialized = False

        # Inicializar widgets espec√≠ficos para admin
        if ADMIN_WIDGETS_AVAILABLE:
            self.admin_widgets = AdminWidgets()
        else:
            self.admin_widgets = None

        # Inicializar sistemas administrativos de forma segura
        self._initialize_admin_systems()

    def _initialize_admin_systems(self):
        """Inicializar sistemas administrativos de forma segura"""
        try:
            # Intentar importar directamente las clases mock
            from modules.admin.mock_systems import (
                MockPerformanceOptimizer, MockSecurityAuditor,
                MockRateLimiter, MockDataEncryption
            )

            self.performance_optimizer = MockPerformanceOptimizer()
            self.security_auditor = MockSecurityAuditor()
            self.rate_limiter = MockRateLimiter()
            self.data_encryption = MockDataEncryption()
            self.systems_initialized = True
            print("‚úÖ Sistemas mock inicializados directamente")

            # Verificar que se inicializaron correctamente
            if hasattr(st, 'success'):
                st.success("üéâ Sistemas administrativos inicializados correctamente")

        except ImportError as e:
            print(f"‚ùå Error importando sistemas mock: {str(e)}")
            self.systems_initialized = False
            if hasattr(st, 'error'):
                st.error(f"‚ùå Error importando sistemas: {str(e)}")
        except Exception as e:
            print(f"‚ùå Error inicializando sistemas: {str(e)}")
            self.systems_initialized = False
            if hasattr(st, 'error'):
                st.error(f"‚ùå Error inicializando sistemas: {str(e)}")
                import traceback
                st.code(traceback.format_exc())

    def initialize_systems(self, performance_optimizer, security_auditor, rate_limiter, data_encryption):
        """Inicializar sistemas de optimizaci√≥n y seguridad (m√©todo legacy)"""
        if performance_optimizer:
            self.performance_optimizer = performance_optimizer
        if security_auditor:
            self.security_auditor = security_auditor
        if rate_limiter:
            self.rate_limiter = rate_limiter
        if data_encryption:
            self.data_encryption = data_encryption

        self.systems_initialized = True

    def _ensure_mock_systems(self):
        """Asegurar que los sistemas mock est√©n inicializados"""
        try:
            if MOCK_SYSTEMS_AVAILABLE:
                systems = initialize_admin_systems_safely()
                if not self.performance_optimizer:
                    self.performance_optimizer = systems.get('performance_optimizer')
                if not self.security_auditor:
                    self.security_auditor = systems.get('security_auditor')
                if not self.rate_limiter:
                    self.rate_limiter = systems.get('rate_limiter')
                if not self.data_encryption:
                    self.data_encryption = systems.get('data_encryption')
                self.systems_initialized = True
                st.info("üîÑ Sistemas mock inicializados din√°micamente")
            else:
                st.error("‚ùå Sistemas mock no disponibles")
        except Exception as e:
            st.error(f"‚ùå Error inicializando sistemas mock: {str(e)}")
            import traceback
            st.code(traceback.format_exc())

    def render_admin_dashboard(self):
        """Renderizar dashboard completo de administraci√≥n"""
        st.markdown("# üè• Dashboard de Administraci√≥n Sanitaria")
        st.markdown("Panel de control para la gesti√≥n integral del sistema de salud andaluz")

        # Forzar limpieza de cache si es necesario
        if st.button("üîÑ Reiniciar Dashboard (Limpiar Cache)"):
            # Limpiar session state relacionado con admin
            keys_to_clear = [k for k in st.session_state.keys() if 'admin' in k.lower()]
            for key in keys_to_clear:
                del st.session_state[key]
            st.rerun()

        # Debug info
        if not self.systems_initialized:
            st.error("‚ö†Ô∏è Sistemas administrativos no inicializados - Reintentando...")
            self._initialize_admin_systems()

        # Mostrar estado de sistemas
        with st.expander("üîß Estado de Sistemas (Debug)"):
            col1, col2, col3, col4, col5 = st.columns(5)
            with col1:
                status = "‚úÖ" if self.performance_optimizer else "‚ùå"
                st.write(f"{status} Performance Optimizer")
            with col2:
                status = "‚úÖ" if self.security_auditor else "‚ùå"
                st.write(f"{status} Security Auditor")
            with col3:
                status = "‚úÖ" if self.rate_limiter else "‚ùå"
                st.write(f"{status} Rate Limiter")
            with col4:
                status = "‚úÖ" if self.data_encryption else "‚ùå"
                st.write(f"{status} Data Encryption")
            with col5:
                if st.button("üîÑ Reinicializar"):
                    self._initialize_admin_systems()
                    st.rerun()
        
        # Tabs para diferentes secciones
        tab1, tab2, tab3, tab4, tab5, tab6, tab7 = st.tabs([
            "üè• Panel Ejecutivo", "üìä Rendimiento", "üîí Seguridad",
            "üö¶ Rate Limiting", "üîê Encriptaci√≥n", "üìà Analytics", "üéØ Insights Estrat√©gicos"
        ])

        with tab1:
            self._render_executive_dashboard_tab()

        with tab2:
            self._render_performance_tab()

        with tab3:
            self._render_security_tab()

        with tab4:
            self._render_rate_limiting_tab()

        with tab5:
            self._render_encryption_tab()

        with tab6:
            self._render_analytics_tab()

        with tab7:
            self._render_strategic_insights_tab()
        
        # Tab adicional para procesamiento as√≠ncrono
        with st.expander("ü§ñ Procesamiento As√≠ncrono de IA"):
            self._render_async_processing_tab()

    def _render_executive_dashboard_tab(self):
        """Panel ejecutivo para administradores del sistema sanitario"""
        st.markdown("## üè• Panel Ejecutivo del Sistema Sanitario")
        st.markdown("Tablero de control para la gesti√≥n estrat√©gica y operativa del sistema de salud andaluz")

        # Solo disponible para administradores
        if not self.admin_widgets:
            st.error("‚ùå Widgets de administraci√≥n no disponibles")
            return

        # Obtener datos del sistema si est√°n disponibles
        data = getattr(st.session_state, 'app_data', {})

        # Widget de resumen del sistema sanitario
        self.admin_widgets.render_health_system_overview_widget()

        st.markdown("---")

        # KPIs ejecutivos avanzados del sistema sanitario
        self.admin_widgets.render_advanced_kpi_dashboard(data)

        st.markdown("---")

        # Panel de alertas sanitarias (m√°s relevante que activity heatmap)
        self.admin_widgets.render_health_alerts_widget()

        st.markdown("---")

        # An√°lisis predictivo
        if data:
            self.admin_widgets.render_predictive_analytics_widget(data)

    def _render_strategic_insights_tab(self):
        """Tab de insights estrat√©gicos"""
        st.markdown("## üîÆ Insights Estrat√©gicos")
        st.markdown("An√°lisis estrat√©gico y recomendaciones basadas en inteligencia de datos")

        if not self.admin_widgets:
            st.error("‚ùå Widgets de administraci√≥n no disponibles")
            return

        # Obtener datos del sistema
        data = getattr(st.session_state, 'app_data', {})

        # Si no hay datos, generar datos de ejemplo para el an√°lisis
        if not data:
            data = self._generate_sample_analysis_data()

        # Widgets de insights estrat√©gicos
        self.admin_widgets.render_strategic_insights_widget(data)

        st.markdown("---")

        # Comparativa de rendimiento por distritos
        self.admin_widgets.render_performance_comparison_chart(data)

        st.markdown("---")

        # Panel de control estrat√©gico adicional
        self._render_strategic_control_panel()

    def _generate_sample_analysis_data(self):
        """Generar datos de ejemplo para an√°lisis estrat√©gicos"""
        import pandas as pd
        import numpy as np

        # Datos de indicadores por distrito de M√°laga
        distritos = [
            'Centro', 'Este', 'Ciudad Jard√≠n', 'Bail√©n-Miraflores',
            'Palma-Palmilla', 'Cruz de Humilladero', 'Carretera de C√°diz',
            'Churriana', 'Campanillas', 'Puerto de la Torre'
        ]

        # Generar datos realistas
        np.random.seed(42)  # Para reproducibilidad

        indicadores_data = []
        for distrito in distritos:
            indicadores_data.append({
                'distrito': distrito,
                'poblacion': np.random.randint(45000, 120000),
                'centros_salud': np.random.randint(2, 8),
                'medicos_familia': np.random.randint(15, 45),
                'enfermeros': np.random.randint(25, 70),
                'consultas_mes': np.random.randint(2500, 8500),
                'tiempo_espera_dias': np.random.randint(5, 25),
                'satisfaccion_pct': np.random.randint(75, 95),
                'urgencias_mes': np.random.randint(800, 2200),
                'derivaciones_especialista': np.random.randint(150, 450),
                'indice_salud': round(np.random.uniform(7.2, 9.1), 1)
            })

        return {
            'indicadores': pd.DataFrame(indicadores_data),
            'distritos': distritos,
            'timestamp': pd.Timestamp.now()
        }

    def _render_strategic_control_panel(self):
        """Panel de control estrat√©gico adicional"""
        st.markdown("#### üéØ Panel de Control Estrat√©gico")

        col1, col2 = st.columns(2)

        with col1:
            st.markdown("##### üìã Acciones Estrat√©gicas Pendientes")

            strategic_actions = [
                {"action": "üè• Evaluaci√≥n nuevos centros Costa del Sol", "deadline": "Q2 2025", "priority": "Alta"},
                {"action": "üìä An√°lisis ROI telemedicina", "deadline": "Q1 2025", "priority": "Media"},
                {"action": "üë• Plan recursos humanos geri√°tricos", "deadline": "Q3 2025", "priority": "Alta"},
                {"action": "üí∞ Optimizaci√≥n presupuestaria hospitales", "deadline": "Q1 2025", "priority": "Cr√≠tica"}
            ]

            for action in strategic_actions:
                priority_color = {
                    'Cr√≠tica': '#e53e3e',
                    'Alta': '#ff8c00',
                    'Media': '#0066cc'
                }.get(action['priority'], '#6b7280')

                st.markdown(f"""
                <div style="
                    background: white;
                    padding: 1.2rem;
                    border-radius: 10px;
                    border-left: 5px solid {priority_color};
                    margin: 0.8rem 0;
                    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
                    border: 1px solid #e2e8f0;
                ">
                    <div style="
                        color: #000000;
                        font-weight: 700;
                        font-size: 1.1rem;
                        margin-bottom: 0.6rem;
                        line-height: 1.4;
                    ">{action['action']}</div>
                    <div style="display: flex; align-items: center; gap: 1rem;">
                        <span style="
                            color: #000000;
                            font-size: 0.95rem;
                            font-weight: 600;
                        ">üìÖ {action['deadline']}</span>
                        <span style="
                            background: {priority_color};
                            color: white;
                            padding: 0.3rem 0.8rem;
                            border-radius: 12px;
                            font-size: 0.8rem;
                            font-weight: 600;
                            text-transform: uppercase;
                            letter-spacing: 0.5px;
                        ">‚ö° {action['priority']}</span>
                    </div>
                </div>
                """, unsafe_allow_html=True)

        with col2:
            st.markdown("##### üìà M√©tricas de Rendimiento Ejecutivo")

            # M√©tricas ejecutivas simuladas
            exec_metrics = {
                "üìä Eficiencia Operativa": {"value": "94.2%", "trend": "‚ÜóÔ∏è +2.1%"},
                "üí∞ Control Presupuestario": {"value": "‚Ç¨2.3M", "trend": "‚ÜòÔ∏è -‚Ç¨120K"},
                "üéØ Objetivos Cumplidos": {"value": "87%", "trend": "‚ÜóÔ∏è +5%"},
                "‚ö° Tiempo Implementaci√≥n": {"value": "12.3 d√≠as", "trend": "‚ÜòÔ∏è -1.2 d√≠as"}
            }

            for metric, data in exec_metrics.items():
                st.markdown(f"""
                <div style="
                    background: white;
                    padding: 1.3rem;
                    border-radius: 10px;
                    margin: 0.8rem 0;
                    border: 2px solid #e2e8f0;
                    box-shadow: 0 2px 8px rgba(0,0,0,0.08);
                ">
                    <div style="
                        font-weight: 700;
                        color: #000000;
                        font-size: 1.05rem;
                        margin-bottom: 0.6rem;
                    ">{metric}</div>
                    <div style="
                        font-size: 1.6rem;
                        font-weight: 700;
                        color: #000000;
                        margin: 0.5rem 0;
                    ">{data['value']}</div>
                    <div style="
                        font-size: 1rem;
                        color: #000000;
                        font-weight: 600;
                    ">{data['trend']}</div>
                </div>
                """, unsafe_allow_html=True)

        # Controles administrativos avanzados
        st.markdown("---")
        st.markdown("##### üõ†Ô∏è Controles Administrativos Avanzados")

        col1, col2, col3, col4 = st.columns(4)

        with col1:
            if st.button("üîÑ Actualizar Cache Global", help="Actualizar todos los caches del sistema"):
                st.success("‚úÖ Cache global actualizado")

        with col2:
            if st.button("üìä Generar Reporte Ejecutivo", help="Generar reporte ejecutivo completo"):
                st.info("üìÑ Reporte ejecutivo gener√°ndose...")

        with col3:
            if st.button("üîç Auditor√≠a Completa", help="Ejecutar auditor√≠a completa del sistema"):
                st.info("üîç Auditor√≠a en progreso...")

        with col4:
            if st.button("üìà An√°lisis Predictivo", help="Ejecutar an√°lisis predictivo avanzado"):
                st.info("üîÆ An√°lisis predictivo ejecut√°ndose...")

    def _render_performance_tab(self):
        """Tab de rendimiento del sistema"""
        st.markdown("## üìä Monitoreo de Rendimiento del Sistema")

        # Siempre usar datos simulados para el dashboard administrativo
        st.info("üìä M√©tricas de rendimiento del sistema (datos simulados)")
        self._render_performance_fallback()
        return
        
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            st.metric("üì¶ Entradas en Cache", cache_stats.get('total_entries', 0))
        
        with col2:
            st.metric("üíæ Uso de Memoria", cache_stats.get('memory_usage', '0 MB'))
        
        with col3:
            entries_by_role = cache_stats.get('entries_by_role', {})
            total_roles = len(entries_by_role)
            st.metric("üë• Roles Activos", total_roles)
        
        with col4:
            if entries_by_role:
                max_entries = max(entries_by_role.values())
                st.metric("üî• Cache M√°s Usado", f"{max_entries} entradas")
        
        # Gr√°fico de uso de cache por rol
        if entries_by_role:
            st.markdown("### üìà Uso de Cache por Rol")
            
            roles = list(entries_by_role.keys())
            entries = list(entries_by_role.values())
            
            fig = px.bar(
                x=roles, y=entries,
                title="Entradas de Cache por Rol de Usuario",
                color=entries,
                color_continuous_scale='Viridis'
            )
            fig.update_layout(
                xaxis_title="Rol de Usuario",
                yaxis_title="N√∫mero de Entradas"
            )
            st.plotly_chart(fig, use_container_width=True)
        
        # Controles de cache
        st.markdown("### üõ†Ô∏è Gesti√≥n de Cache")
        
        col1, col2 = st.columns(2)
        
        with col1:
            if st.button("üóëÔ∏è Limpiar Todo el Cache"):
                self.performance_optimizer.clear_user_cache()
                st.success("‚úÖ Cache limpiado exitosamente")
                st.rerun()
        
        with col2:
            selected_role = st.selectbox(
                "Limpiar cache por rol:",
                ["admin", "gestor", "analista", "invitado"]
            )
            if st.button(f"üóëÔ∏è Limpiar Cache de {selected_role}"):
                self.performance_optimizer.clear_user_cache(selected_role)
                st.success(f"‚úÖ Cache de {selected_role} limpiado")
                st.rerun()
    
    def _render_security_tab(self):
        """Tab de seguridad del sistema"""
        st.markdown("## üîí Monitoreo de Seguridad del Sistema")

        # Siempre usar datos simulados para el dashboard administrativo
        st.info("üîí M√©tricas de seguridad del sistema (datos simulados)")
        self._render_security_fallback()
        return
        
        if 'error' in security_data:
            st.error(f"‚ùå Error obteniendo datos de seguridad: {security_data['error']}")
            return
        
        # M√©tricas principales
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            st.metric("üìä Acciones Totales", security_data.get('total_actions', 0))
        
        with col2:
            st.metric("‚ùå Acciones Fallidas", security_data.get('failed_actions', 0))
        
        with col3:
            success_rate = security_data.get('success_rate', 0)
            st.metric("‚úÖ Tasa de √âxito", f"{success_rate:.1f}%")
        
        with col4:
            st.metric("üë• Usuarios √önicos", security_data.get('unique_users', 0))
        
        # Gr√°fico de acciones por tipo
        action_types = security_data.get('action_types', {})
        if action_types:
            st.markdown("### üìà Distribuci√≥n de Acciones")
            
            fig = px.pie(
                values=list(action_types.values()),
                names=list(action_types.keys()),
                title="Acciones por Tipo (√öltimas 24 horas)"
            )
            st.plotly_chart(fig, use_container_width=True)
        
        # Top usuarios m√°s activos
        top_users = security_data.get('top_users', [])
        if top_users:
            st.markdown("### üë• Usuarios M√°s Activos")
            
            df_users = pd.DataFrame(top_users, columns=['Usuario', 'Acciones'])
            
            fig = px.bar(
                df_users, x='Usuario', y='Acciones',
                title="Top 10 Usuarios por Actividad",
                color='Acciones',
                color_continuous_scale='Blues'
            )
            fig.update_xaxes(tickangle=45)
            st.plotly_chart(fig, use_container_width=True)
        
        # Detecci√≥n de actividad sospechosa
        st.markdown("### üö® Actividad Sospechosa")
        
        # Simular detecci√≥n (en producci√≥n esto vendr√≠a del sistema real)
        suspicious_activities = [
            {"user": "usuario1", "type": "high_frequency", "count": 150, "risk_level": 75},
            {"user": "usuario2", "type": "failed_logins", "count": 8, "risk_level": 90}
        ]
        
        if suspicious_activities:
            for activity in suspicious_activities:
                risk_color = "üî¥" if activity['risk_level'] > 80 else "üü°" if activity['risk_level'] > 50 else "üü¢"
                st.warning(f"{risk_color} **{activity['user']}**: {activity['type']} ({activity['count']} veces) - Riesgo: {activity['risk_level']}%")
        else:
            st.success("‚úÖ No se detect√≥ actividad sospechosa")
    
    def _render_rate_limiting_tab(self):
        """Tab de control de tr√°fico"""
        st.markdown("## üö¶ Control de Tr√°fico y L√≠mites del Sistema")

        # Siempre usar datos simulados para el dashboard administrativo
        st.info("üö¶ M√©tricas de control de tr√°fico (datos simulados)")
        self._render_rate_limiting_fallback()
        return
        
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            st.metric("üö´ Usuarios Bloqueados", system_stats.get('active_blocks', 0))
        
        with col2:
            st.metric("‚ö†Ô∏è IPs Sospechosas", system_stats.get('suspicious_ips', 0))
        
        with col3:
            st.metric("üìä L√≠mites Configurados", system_stats.get('total_limits', 0))
        
        with col4:
            total_requests = sum(system_stats.get('active_requests', {}).values())
            st.metric("üîÑ Requests Activos", total_requests)
        
        # Requests activos por tipo
        active_requests = system_stats.get('active_requests', {})
        if active_requests:
            st.markdown("### üìà Requests Activos por Tipo")
            
            df_requests = pd.DataFrame([
                {"Tipo": k, "Requests": v} for k, v in active_requests.items()
            ])
            
            fig = px.bar(
                df_requests, x='Tipo', y='Requests',
                title="Requests Activos por Tipo de Acci√≥n",
                color='Requests',
                color_continuous_scale='Reds'
            )
            fig.update_xaxes(tickangle=45)
            st.plotly_chart(fig, use_container_width=True)
        
        # Gesti√≥n de bloqueos
        st.markdown("### üõ†Ô∏è Gesti√≥n de Bloqueos")
        
        col1, col2 = st.columns(2)
        
        with col1:
            st.markdown("#### Usuarios Bloqueados")
            # En una implementaci√≥n real, esto vendr√≠a de la base de datos
            blocked_users = ["usuario1", "usuario2"]  # Simulado
            
            if blocked_users:
                for user in blocked_users:
                    col_user, col_action = st.columns([3, 1])
                    with col_user:
                        st.write(f"üö´ {user}")
                    with col_action:
                        if st.button(f"Desbloquear", key=f"unblock_{user}"):
                            # L√≥gica de desbloqueo
                            st.success(f"‚úÖ {user} desbloqueado")
            else:
                st.success("‚úÖ No hay usuarios bloqueados")
        
        with col2:
            st.markdown("#### IPs Sospechosas")
            suspicious_ips = ["192.168.1.100", "10.0.0.50"]  # Simulado
            
            if suspicious_ips:
                for ip in suspicious_ips:
                    col_ip, col_action = st.columns([3, 1])
                    with col_ip:
                        st.write(f"‚ö†Ô∏è {ip}")
                    with col_action:
                        if st.button(f"Limpiar", key=f"clear_{ip}"):
                            # L√≥gica de limpieza
                            st.success(f"‚úÖ {ip} limpiada")
            else:
                st.success("‚úÖ No hay IPs sospechosas")
    
    def _render_encryption_tab(self):
        """Tab de seguridad de datos"""
        st.markdown("## üîê Seguridad y Encriptaci√≥n de Datos")

        # Siempre usar datos simulados para el dashboard administrativo
        st.info("üîê Estado de seguridad de datos (datos simulados)")
        self._render_encryption_fallback()
        return
        
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            algorithm = encryption_status.get('algorithm', 'N/A')
            st.metric("üîê Algoritmo", algorithm)
        
        with col2:
            key_exists = encryption_status.get('key_exists', False)
            status_icon = "‚úÖ" if key_exists else "‚ùå"
            st.metric("üîë Clave", f"{status_icon} {'Existe' if key_exists else 'No existe'}")
        
        with col3:
            salt_exists = encryption_status.get('salt_exists', False)
            status_icon = "‚úÖ" if salt_exists else "‚ùå"
            st.metric("üßÇ Salt", f"{status_icon} {'Existe' if salt_exists else 'No existe'}")
        
        with col4:
            last_modified = encryption_status.get('last_modified', 'N/A')
            st.metric("üìÖ √öltima Modificaci√≥n", last_modified[:10] if last_modified != 'N/A' else 'N/A')
        
        # Validaci√≥n de integridad
        st.markdown("### üîç Validaci√≥n de Integridad")
        
        if st.button("üß™ Probar Sistema de Encriptaci√≥n"):
            with st.spinner("Probando encriptaci√≥n..."):
                integrity_test = self.data_encryption.validate_encryption_integrity()
                
                if integrity_test.get('encryption_working', False):
                    st.success("‚úÖ Sistema de encriptaci√≥n funcionando correctamente")
                else:
                    st.error(f"‚ùå Error en sistema de encriptaci√≥n: {integrity_test.get('error', 'Desconocido')}")
                
                # Mostrar detalles del test
                with st.expander("üìã Detalles del Test"):
                    st.json(integrity_test)
        
        # Gesti√≥n de claves
        st.markdown("### üõ†Ô∏è Gesti√≥n de Claves")
        
        col1, col2 = st.columns(2)
        
        with col1:
            if st.button("üîÑ Rotar Clave de Encriptaci√≥n"):
                st.warning("‚ö†Ô∏è Esta acci√≥n requiere re-encriptar todos los datos existentes")
                if st.button("‚úÖ Confirmar Rotaci√≥n", type="primary"):
                    success = self.data_encryption.rotate_encryption_key()
                    if success:
                        st.success("‚úÖ Clave rotada exitosamente")
                    else:
                        st.error("‚ùå Error rotando clave")
        
        with col2:
            st.info("üí° **Nota**: La rotaci√≥n de claves es una operaci√≥n cr√≠tica que afecta todos los datos encriptados")
    
    def _render_async_processing_tab(self):
        """Tab de procesamiento as√≠ncrono de IA"""
        st.markdown("## ü§ñ Procesamiento As√≠ncrono de IA")
        
        try:
            # Importar m√≥dulo de IA
            from modules.ai.ai_processor import HealthAnalyticsAI
            
            # Crear instancia temporal para obtener m√©tricas
            ai_processor = HealthAnalyticsAI()
            
            # Obtener m√©tricas de procesamiento as√≠ncrono
            metrics = ai_processor.get_async_processing_metrics()
            
            if 'error' in metrics:
                st.error(f"‚ùå Error obteniendo m√©tricas: {metrics['error']}")
                return
            
            # M√©tricas principales
            col1, col2, col3, col4 = st.columns(4)
            
            with col1:
                total_requests = metrics.get('total_requests', 0)
                st.metric("üîÑ Total Requests", total_requests)
            
            with col2:
                successful = metrics.get('successful_requests', 0)
                success_rate = (successful / max(1, total_requests)) * 100
                st.metric("‚úÖ Tasa de √âxito", f"{success_rate:.1f}%")
            
            with col3:
                avg_time = metrics.get('average_response_time', 0)
                st.metric("‚è±Ô∏è Tiempo Promedio", f"{avg_time:.2f}s")
            
            with col4:
                cache_hits = metrics.get('cache_hits', 0)
                cache_rate = (cache_hits / max(1, total_requests)) * 100
                st.metric("üíæ Cache Hit Rate", f"{cache_rate:.1f}%")
            
            # Gr√°fico de rendimiento en el tiempo (simulado)
            st.markdown("### üìà Rendimiento del Procesamiento As√≠ncrono")
            
            # Generar datos simulados para el gr√°fico
            import plotly.graph_objects as go
            from datetime import datetime, timedelta
            
            # Simular datos de las √∫ltimas 24 horas
            hours = [(datetime.now() - timedelta(hours=i)).strftime('%H:00') for i in range(23, -1, -1)]
            response_times = [max(0.5, 2.0 + (i % 3) * 0.5 + (i % 7) * 0.3) for i in range(24)]
            success_rates = [min(100, 85 + (i % 5) * 3 + (i % 11) * 2) for i in range(24)]
            
            # Crear gr√°fico de l√≠neas
            fig = go.Figure()
            
            fig.add_trace(go.Scatter(
                x=hours, y=response_times,
                mode='lines+markers',
                name='Tiempo de Respuesta (s)',
                yaxis='y',
                line=dict(color='blue')
            ))
            
            fig.add_trace(go.Scatter(
                x=hours, y=success_rates,
                mode='lines+markers',
                name='Tasa de √âxito (%)',
                yaxis='y2',
                line=dict(color='green')
            ))
            
            fig.update_layout(
                title="Rendimiento del Procesamiento As√≠ncrono (√öltimas 24h)",
                xaxis_title="Hora",
                yaxis=dict(title="Tiempo de Respuesta (s)", side="left"),
                yaxis2=dict(title="Tasa de √âxito (%)", side="right", overlaying="y"),
                hovermode=False  # Deshabilitar hover para evitar errores
            )
            
            st.plotly_chart(fig, use_container_width=True)
            
            # Controles de gesti√≥n
            st.markdown("### üõ†Ô∏è Gesti√≥n del Procesamiento As√≠ncrono")
            
            col1, col2 = st.columns(2)
            
            with col1:
                if st.button("üóëÔ∏è Limpiar Cache de IA"):
                    try:
                        ai_processor.clear_async_cache()
                        st.success("‚úÖ Cache de IA limpiado")
                        st.rerun()
                    except Exception as e:
                        st.error(f"‚ùå Error limpiando cache: {str(e)}")
            
            with col2:
                if st.button("üîÑ Reiniciar Procesador As√≠ncrono"):
                    st.info("üîÑ Reiniciando procesador as√≠ncrono...")
                    # En una implementaci√≥n real, aqu√≠ se reiniciar√≠a el procesador
                    st.success("‚úÖ Procesador as√≠ncrono reiniciado")
            
            # Estado del sistema
            st.markdown("### üìä Estado del Sistema As√≠ncrono")
            
            status_items = [
                ("üîÑ Procesamiento As√≠ncrono", "‚úÖ Activo"),
                ("üíæ Cache de Respuestas", "‚úÖ Activo"),
                ("üîÑ Pool de Threads", "‚úÖ Activo"),
                ("üìä M√©tricas", "‚úÖ Recolectando"),
                ("üîí Rate Limiting", "‚úÖ Integrado"),
                ("üìù Auditor√≠a", "‚úÖ Activa")
            ]
            
            for item, status in status_items:
                col1, col2 = st.columns([2, 1])
                with col1:
                    st.write(f"**{item}:**")
                with col2:
                    st.write(status)
            
        except Exception as e:
            st.error(f"‚ùå Error en procesamiento as√≠ncrono: {str(e)}")
            st.info("üí° Aseg√∫rate de que el m√≥dulo de IA est√© disponible")

    def _render_performance_fallback(self):
        """Renderizar tab de rendimiento del sistema sanitario"""
        st.markdown("### üìä Rendimiento del Sistema Sanitario")

        # M√©tricas de rendimiento del sistema de salud
        col1, col2, col3, col4 = st.columns(4)

        with col1:
            st.metric("‚ö° Tiempo Consulta", "2.3 min", delta="-0.4 min", help="Tiempo promedio de consulta m√©dica")

        with col2:
            st.metric("üè• Disponibilidad Sistema", "99.2%", delta="+0.1%", help="Disponibilidad del sistema de informaci√≥n sanitario")

        with col3:
            st.metric("üë• Usuarios Concurrentes", "847", help="Profesionales sanitarios conectados")

        with col4:
            st.metric("üìä Transacciones/min", "2,340", delta="+156", help="Transacciones sanitarias por minuto")

        # Gr√°fico de rendimiento del sistema por servicio
        st.markdown("### üìà Rendimiento por Servicio Sanitario")

        services = ['Atenci√≥n Primaria', 'Especialidades', 'Urgencias', 'Hospitalizaci√≥n', 'Laboratorio']
        response_times = [1.2, 3.4, 0.8, 2.1, 4.2]  # minutos

        fig = px.bar(
            x=services, y=response_times,
            title="Tiempo de Respuesta por Servicio (minutos)",
            color=response_times,
            color_continuous_scale='RdYlGn_r'  # Rojo para tiempos altos, verde para bajos
        )
        fig.update_layout(
            xaxis_title="Servicio Sanitario",
            yaxis_title="Tiempo de Respuesta (min)",
            height=400
        )
        st.plotly_chart(fig, use_container_width=True)

        # Controles de optimizaci√≥n
        st.markdown("### üõ†Ô∏è Optimizaci√≥n del Sistema")

        col1, col2 = st.columns(2)

        with col1:
            if st.button("‚ö° Optimizar Rendimiento General"):
                st.success("‚úÖ Optimizaci√≥n ejecutada - Mejora estimada del 12%")

        with col2:
            selected_service = st.selectbox(
                "Optimizar servicio espec√≠fico:",
                services
            )
            if st.button(f"üéØ Optimizar {selected_service}"):
                st.success(f"‚úÖ {selected_service} optimizado correctamente")

    def _render_security_fallback(self):
        """Renderizar tab de seguridad del sistema sanitario"""
        st.markdown("### üîí Seguridad del Sistema Sanitario")

        # M√©tricas de seguridad espec√≠ficas del sistema de salud
        col1, col2, col3, col4 = st.columns(4)

        with col1:
            st.metric("üîê Accesos Sistema", "2,847", delta="+156", help="Accesos diarios al sistema sanitario")

        with col2:
            st.metric("‚ùå Intentos Fallidos", "12", delta="-3", help="Intentos de acceso fallidos")

        with col3:
            st.metric("‚úÖ Cumplimiento LOPD", "98.7%", delta="+0.2%", help="Cumplimiento Ley Protecci√≥n de Datos")

        with col4:
            st.metric("üõ°Ô∏è Auditor√≠as Exitosas", "847", help="Auditor√≠as de seguridad completadas")

        # Gr√°fico de accesos por servicio
        st.markdown("### üìà Accesos por Servicio Sanitario")

        access_types = {
            'Historia Cl√≠nica': 1847,
            'Prescripci√≥n Electr√≥nica': 1243,
            'Citas M√©dicas': 892,
            'Resultados Laboratorio': 674,
            'Informes Radiolog√≠a': 423,
            'Administraci√≥n': 156
        }

        fig = px.pie(
            values=list(access_types.values()),
            names=list(access_types.keys()),
            title="Distribuci√≥n de Accesos por Servicio"
        )
        st.plotly_chart(fig, use_container_width=True)

        # Panel de alertas de seguridad
        st.markdown("### üö® Estado de Seguridad")

        col1, col2 = st.columns(2)

        with col1:
            st.success("‚úÖ Todos los sistemas cumplen normativa sanitaria")
            st.success("‚úÖ Encriptaci√≥n de datos m√©dicos activa")
            st.success("‚úÖ Backup de historias cl√≠nicas actualizado")

        with col2:
            st.info("‚ÑπÔ∏è Pr√≥xima auditor√≠a LOPD: 15 d√≠as")
            st.info("‚ÑπÔ∏è Certificados SSL v√°lidos hasta Dic 2025")
            st.warning("‚ö†Ô∏è Revisar accesos usuarios inactivos > 90 d√≠as")

    def _render_rate_limiting_fallback(self):
        """Renderizar tab de control de tr√°fico del sistema sanitario"""
        st.markdown("### üö¶ Control de Tr√°fico del Sistema Sanitario")

        col1, col2, col3, col4 = st.columns(4)

        with col1:
            st.metric("üö´ Accesos Limitados", "3", help="Usuarios temporalmente limitados por exceso de consultas")

        with col2:
            st.metric("‚ö†Ô∏è Centros en Alerta", "2", help="Centros sanitarios con tr√°fico alto")

        with col3:
            st.metric("üìä Pol√≠ticas Activas", "15", help="Pol√≠ticas de control de tr√°fico configuradas")

        with col4:
            st.metric("üîÑ Consultas/Segundo", "127", delta="+23", help="Consultas al sistema por segundo")

        # Gr√°fico de tr√°fico por hora
        st.markdown("### üìà Tr√°fico del Sistema por Hora")

        import numpy as np
        import plotly.graph_objects as go

        hours = list(range(24))
        traffic = [
            20, 15, 12, 10, 8, 15, 45, 89, 125, 156,
            167, 178, 189, 195, 187, 176, 165, 152,
            138, 124, 98, 76, 54, 32
        ]

        fig = go.Figure()
        fig.add_trace(go.Scatter(
            x=hours, y=traffic,
            mode='lines+markers',
            name='Consultas/min',
            line=dict(color='#3b82f6', width=3),
            fill='tonexty'
        ))

        fig.update_layout(
            title="Tr√°fico del Sistema Sanitario (24 horas)",
            xaxis_title="Hora del d√≠a",
            yaxis_title="Consultas por minuto",
            height=350
        )
        st.plotly_chart(fig, use_container_width=True)

        # Controles de tr√°fico
        st.markdown("### üõ†Ô∏è Gesti√≥n de Tr√°fico")

        col1, col2 = st.columns(2)

        with col1:
            if st.button("‚ö° Aumentar L√≠mites Temporalmente"):
                st.success("‚úÖ L√≠mites incrementados por 2 horas")

        with col2:
            if st.button("üîÑ Balancear Carga Autom√°ticamente"):
                st.success("‚úÖ Balanceador de carga optimizado")

    def _render_encryption_fallback(self):
        """Renderizar tab de seguridad de datos del sistema sanitario"""
        st.markdown("### üîê Seguridad de Datos Sanitarios")

        col1, col2, col3, col4 = st.columns(4)

        with col1:
            st.metric("üîê Algoritmo", "AES-256-GCM", help="Encriptaci√≥n de historias cl√≠nicas")

        with col2:
            st.metric("üîë Certificados", "‚úÖ V√°lidos", help="Certificados digitales del sistema")

        with col3:
            st.metric("üßÇ Hash Seguro", "‚úÖ SHA-256", help="Hash para integridad de datos")

        with col4:
            st.metric("üìÖ √öltima Auditor√≠a", datetime.now().strftime("%d-%m-%Y"), help="√öltima auditor√≠a de seguridad")

        # Estado de protecci√≥n de datos
        st.markdown("### üõ°Ô∏è Estado de Protecci√≥n de Datos M√©dicos")

        col1, col2 = st.columns(2)

        with col1:
            st.markdown("""
            **üè• Datos Protegidos:**
            - ‚úÖ Historias Cl√≠nicas Encriptadas
            - ‚úÖ Resultados Laboratorio Seguros
            - ‚úÖ Im√°genes M√©dicas Protegidas
            - ‚úÖ Recetas Electr√≥nicas Cifradas
            - ‚úÖ Citas M√©dicas Anonimizadas
            """)

        with col2:
            st.markdown("""
            **üìã Cumplimiento Normativo:**
            - ‚úÖ RGPD (Reglamento General de Protecci√≥n de Datos)
            - ‚úÖ LOPD (Ley Org√°nica de Protecci√≥n de Datos)
            - ‚úÖ Normativa Sanitaria Andaluza
            - ‚úÖ ISO 27001 (Gesti√≥n de Seguridad)
            - ‚úÖ ENS (Esquema Nacional de Seguridad)
            """)

        # Controles de encriptaci√≥n
        st.markdown("### üõ†Ô∏è Gesti√≥n de Seguridad")

        col1, col2, col3 = st.columns(3)

        with col1:
            if st.button("üß™ Verificar Integridad de Datos"):
                with st.spinner("Verificando integridad..."):
                    time.sleep(2)
                    st.success("‚úÖ Integridad de datos m√©dicos verificada")

        with col2:
            if st.button("üîÑ Rotar Claves de Encriptaci√≥n"):
                with st.spinner("Rotando claves..."):
                    time.sleep(3)
                    st.success("‚úÖ Claves rotadas correctamente")

        with col3:
            if st.button("üìä Generar Informe LOPD"):
                with st.spinner("Generando informe..."):
                    time.sleep(2)
                    st.success("‚úÖ Informe LOPD generado y enviado")
    
    def _render_analytics_tab(self):
        """Tab de analytics generales"""
        st.markdown("## üìà Analytics del Sistema")
        
        # M√©tricas generales
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            st.metric("üïê Tiempo de Sesi√≥n", "2h 15m")
        
        with col2:
            st.metric("üìä Datasets Cargados", "5")
        
        with col3:
            st.metric("ü§ñ Consultas IA", "23")
        
        with col4:
            st.metric("üó∫Ô∏è Mapas Generados", "8")
        
        # Gr√°fico de uso en el tiempo (simulado)
        st.markdown("### üìà Uso del Sistema en el Tiempo")
        
        # Generar datos simulados
        hours = list(range(24))
        usage_data = [max(0, 10 + (h - 12) * 2 + (h % 3) * 5) for h in hours]
        
        fig = px.line(
            x=hours, y=usage_data,
            title="Actividad del Sistema por Hora",
            labels={'x': 'Hora del D√≠a', 'y': 'Usuarios Activos'}
        )
        fig.update_layout(
            xaxis_title="Hora del D√≠a",
            yaxis_title="Usuarios Activos"
        )
        st.plotly_chart(fig, use_container_width=True)
        
        # Resumen de rendimiento
        st.markdown("### üìä Resumen de Rendimiento")
        
        performance_summary = {
            "Tiempo de Carga Promedio": "0.03s",
            "Tasa de √âxito": "98.15%",
            "Memoria Utilizada": "45.2 MB",
            "Cache Hit Rate": "87.3%",
            "Errores en 24h": "2",
            "Uptime": "99.9%"
        }
        
        for metric, value in performance_summary.items():
            col1, col2 = st.columns([2, 1])
            with col1:
                st.write(f"**{metric}:**")
            with col2:
                st.write(value)

# Funci√≥n de utilidad para usar el dashboard de administraci√≥n
def get_admin_dashboard() -> AdminDashboard:
    """Obtener instancia del dashboard de administraci√≥n"""
    if 'admin_dashboard' not in st.session_state:
        try:
            dashboard = AdminDashboard()
            st.session_state['admin_dashboard'] = dashboard
            if dashboard.systems_initialized:
                st.success("‚úÖ Dashboard administrativo inicializado correctamente")
            else:
                st.info("üí° Dashboard administrativo funcionando en modo simulaci√≥n")
        except Exception as e:
            st.error(f"‚ùå Error inicializando dashboard administrativo: {str(e)}")
            # Crear dashboard b√°sico sin sistemas
            dashboard = AdminDashboard()
            dashboard.systems_initialized = False
            st.session_state['admin_dashboard'] = dashboard

    return st.session_state['admin_dashboard']


def reset_admin_dashboard():
    """Reinicializar el dashboard administrativo"""
    if 'admin_dashboard' in st.session_state:
        del st.session_state['admin_dashboard']
    return get_admin_dashboard()
