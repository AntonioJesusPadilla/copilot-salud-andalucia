# Crear archivo: testing/test_diagnostic.py
#!/usr/bin/env python3
"""
Test de Diagn√≥stico para Async - Identificar problemas espec√≠ficos
"""

import sys
import os
import asyncio
import traceback
from dotenv import load_dotenv

# A√±adir el directorio ra√≠z al path
project_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
sys.path.insert(0, project_root)

# Cargar variables de entorno desde .env
load_dotenv()

def test_environment():
    """Verificar variables de entorno y configuraci√≥n"""
    print("üîç DIAGN√ìSTICO - ENTORNO")
    print("=" * 40)
    
    # Verificar que el archivo .env existe
    env_file = os.path.join(project_root, ".env")
    if os.path.exists(env_file):
        print(f"   ‚úÖ Archivo .env encontrado: {env_file}")
    else:
        print(f"   ‚ùå Archivo .env no encontrado en: {env_file}")
        print("   üí° Soluci√≥n: Ejecutar python scripts/setup_env.py")
        return False
    
    # Verificar GROQ_API_KEY
    groq_key = os.getenv("GROQ_API_KEY")
    if groq_key and groq_key != "tu_groq_api_key_aqui":
        print(f"   ‚úÖ GROQ_API_KEY: {groq_key[:10]}...")
    elif groq_key == "tu_groq_api_key_aqui":
        print("   ‚ö†Ô∏è GROQ_API_KEY: Configurada pero con valor por defecto")
        print("   üí° Soluci√≥n: Reemplazar con tu API key real de Groq")
        return False
    else:
        print("   ‚ùå GROQ_API_KEY: No encontrada")
        print("   üí° Soluci√≥n: Configurar variable de entorno")
        return False
    
    # Verificar JWT_SECRET_KEY
    jwt_secret = os.getenv("JWT_SECRET_KEY")
    if jwt_secret and jwt_secret != "tu_clave_jwt_super_segura_de_32_caracteres_o_mas":
        print(f"   ‚úÖ JWT_SECRET_KEY: {jwt_secret[:10]}...")
    else:
        print("   ‚ö†Ô∏è JWT_SECRET_KEY: No configurada o valor por defecto")
    
    # Verificar dependencias
    try:
        import aiohttp
        print(f"   ‚úÖ aiohttp: {aiohttp.__version__}")
    except ImportError as e:
        print(f"   ‚ùå aiohttp: {e}")
        return False
    
    try:
        import asyncio
        print(f"   ‚úÖ asyncio: Disponible")
    except ImportError as e:
        print(f"   ‚ùå asyncio: {e}")
        return False
    
    try:
        from dotenv import load_dotenv
        print(f"   ‚úÖ python-dotenv: Disponible")
    except ImportError as e:
        print(f"   ‚ùå python-dotenv: {e}")
        return False
    
    return True

def test_async_processor_creation():
    """Test de creaci√≥n del procesador as√≠ncrono"""
    print("\nüîç DIAGN√ìSTICO - PROCESADOR")
    print("=" * 40)
    
    try:
        from modules.ai.async_ai_processor import AsyncAIProcessor
        
        processor = AsyncAIProcessor()
        print("   ‚úÖ AsyncAIProcessor creado")
        
        # Verificar configuraci√≥n
        print(f"   üìä Modelo: {processor.model}")
        print(f"   üìä Max concurrent: {processor.max_concurrent_requests}")
        print(f"   ÔøΩÔøΩ Timeout: {processor.request_timeout}")
        print(f"   üìä Retry attempts: {processor.retry_attempts}")
        
        return True
        
    except Exception as e:
        print(f"   ‚ùå Error creando procesador: {e}")
        traceback.print_exc()
        return False

async def test_groq_api_connection():
    """Test de conexi√≥n con Groq API"""
    print("\nüîç DIAGN√ìSTICO - API GROQ")
    print("=" * 40)
    
    try:
        from modules.ai.async_ai_processor import AsyncAIProcessor
        
        processor = AsyncAIProcessor()
        
        # Test de conexi√≥n simple
        print("   ÔøΩÔøΩ Probando conexi√≥n con Groq API...")
        
        # Datos de prueba m√≠nimos (formato correcto con DataFrames)
        import pandas as pd
        
        test_data = {
            'hospitales': pd.DataFrame([{'nombre': 'Test Hospital', 'distrito': 'Centro'}]),
            'demografia': pd.DataFrame([{'municipio': 'Test City', 'poblacion_2025': 1000}])
        }
        
        result = await processor.process_query_async(
            "Hola, ¬øfunciona la conexi√≥n?",
            test_data,
            "invitado"
        )
        
        print(f"   üìä Resultado: {result.get('analysis_type', 'error')}")
        
        if 'error' in result:
            print(f"   ‚ùå Error en API: {result['error']}")
            return False
        else:
            print("   ‚úÖ Conexi√≥n con Groq API exitosa")
            return True
            
    except Exception as e:
        print(f"   ‚ùå Error en conexi√≥n API: {e}")
        traceback.print_exc()
        return False

def test_streamlit_wrapper():
    """Test del wrapper de Streamlit"""
    print("\nüîç DIAGN√ìSTICO - WRAPPER")
    print("=" * 40)
    
    try:
        from modules.ai.streamlit_async_wrapper import StreamlitAsyncWrapper
        
        wrapper = StreamlitAsyncWrapper()
        print("   ‚úÖ StreamlitAsyncWrapper creado")
        
        # Test de loop
        loop = wrapper._get_or_create_loop()
        if loop and not loop.is_closed():
            print("   ‚úÖ Loop de asyncio creado")
        else:
            print("   ‚ùå Problema con loop de asyncio")
            return False
        
        return True
        
    except Exception as e:
        print(f"   ‚ùå Error en wrapper: {e}")
        traceback.print_exc()
        return False

async def test_simple_async_flow():
    """Test de flujo as√≠ncrono simple"""
    print("\nüîç DIAGN√ìSTICO - FLUJO SIMPLE")
    print("=" * 40)
    
    try:
        from modules.ai.async_ai_processor import AsyncAIProcessor
        
        processor = AsyncAIProcessor()
        
        # Test muy simple
        print("   üîÑ Probando flujo as√≠ncrono simple...")
        
        # Simular datos m√≠nimos (formato correcto con DataFrames)
        import pandas as pd
        
        test_data = {
            'hospitales': pd.DataFrame([{'nombre': 'Hospital Test', 'distrito': 'Centro'}]),
            'demografia': pd.DataFrame([{'municipio': 'Test City', 'poblacion_2025': 1000}])
        }
        
        # Test directo del procesador
        result = await processor.process_query_async(
            "Test simple",
            test_data,
            "invitado"
        )
        
        print(f"   üìä Tipo de an√°lisis: {result.get('analysis_type', 'error')}")
        print(f"   üìä Error presente: {'error' in result}")
        
        if 'error' in result:
            print(f"   ‚ùå Error espec√≠fico: {result['error']}")
            return False
        else:
            print("   ‚úÖ Flujo as√≠ncrono funciona")
            return True
            
    except Exception as e:
        print(f"   ‚ùå Error en flujo as√≠ncrono: {e}")
        traceback.print_exc()
        return False

def test_env_loading():
    """Test espec√≠fico para verificar carga del archivo .env"""
    print("\nüîç DIAGN√ìSTICO - CARGA .ENV")
    print("=" * 40)
    
    # Verificar archivo .env
    env_file = os.path.join(project_root, ".env")
    if not os.path.exists(env_file):
        print(f"   ‚ùå Archivo .env no existe en: {env_file}")
        return False
    
    print(f"   ‚úÖ Archivo .env existe: {env_file}")
    
    # Leer contenido del archivo .env
    try:
        with open(env_file, 'r', encoding='utf-8') as f:
            content = f.read()
        
        # Verificar que contiene las variables necesarias
        required_vars = ['GROQ_API_KEY', 'JWT_SECRET_KEY', 'SECRET_KEY']
        missing_vars = []
        
        for var in required_vars:
            if f"{var}=" in content:
                print(f"   ‚úÖ {var}: Encontrada en archivo")
            else:
                print(f"   ‚ùå {var}: No encontrada en archivo")
                missing_vars.append(var)
        
        if missing_vars:
            print(f"   ‚ö†Ô∏è Variables faltantes: {missing_vars}")
            return False
        
        # Verificar que las variables se cargan correctamente
        print("\n   üîÑ Verificando carga de variables...")
        
        # Recargar .env para asegurar que se carga
        load_dotenv(override=True)
        
        groq_key = os.getenv("GROQ_API_KEY")
        jwt_secret = os.getenv("JWT_SECRET_KEY")
        secret_key = os.getenv("SECRET_KEY")
        
        if groq_key:
            print(f"   ‚úÖ GROQ_API_KEY cargada: {groq_key[:10]}...")
        else:
            print("   ‚ùå GROQ_API_KEY no se carg√≥")
            return False
        
        if jwt_secret:
            print(f"   ‚úÖ JWT_SECRET_KEY cargada: {jwt_secret[:10]}...")
        else:
            print("   ‚ùå JWT_SECRET_KEY no se carg√≥")
        
        if secret_key:
            print(f"   ‚úÖ SECRET_KEY cargada: {secret_key[:10]}...")
        else:
            print("   ‚ùå SECRET_KEY no se carg√≥")
        
        return True
        
    except Exception as e:
        print(f"   ‚ùå Error leyendo archivo .env: {e}")
        return False

def main():
    """Ejecutar diagn√≥stico completo"""
    print("üîç DIAGN√ìSTICO COMPLETO - ASYNC/AWAIT")
    print("=" * 60)
    
    tests = [
        ("Carga .env", test_env_loading),
        ("Entorno", test_environment),
        ("Procesador", test_async_processor_creation),
        ("Wrapper", test_streamlit_wrapper)
    ]
    
    passed = 0
    for name, test_func in tests:
        if test_func():
            passed += 1
        else:
            print(f"\n‚ö†Ô∏è Test '{name}' fall√≥ - revisar configuraci√≥n")
    
    # Test as√≠ncrono solo si el entorno est√° bien
    print(f"\nüìä TESTS S√çNCRONOS: {passed}/{len(tests)}")
    
    if passed >= 2:  # Al menos carga .env y entorno
        try:
            asyncio.run(test_groq_api_connection())
            asyncio.run(test_simple_async_flow())
            print("\n‚úÖ Tests as√≠ncronos completados")
        except Exception as e:
            print(f"\n‚ùå Error en tests as√≠ncronos: {e}")
    else:
        print("\n‚ö†Ô∏è Saltando tests as√≠ncronos - configurar entorno primero")
    
    print("\n" + "=" * 60)
    print("üí° Si hay errores, revisa la configuraci√≥n de GROQ_API_KEY")
    print("üí° Ejecuta: python scripts/setup_env.py")

if __name__ == "__main__":
    main()